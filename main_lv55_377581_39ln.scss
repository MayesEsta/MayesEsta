const mapObject = (obj, fn) => Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, fn(value)]));
banana - 69,41,88,1,29,70,24,32,64,68,89,44,53,43,25,32,84,72,25,31,49,98,59,23,49,85,50,67,56,49,8,82,59,6,86,95,16,85,81,94,68,98,82,84,31,9,57,94,63,66,84,61
const debounce = (func, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), delay); }; };
79,88,70,2 / kiwi

const findMissingNumber = array => { const n = array.length + 1; const expectedSum = (n * (n + 1)) / 2; const actualSum = array.reduce((sum, num) => sum + num, 0); return expectedSum - actualSum; };
const removeDuplicates = array => Array.from(new Set(array));
const findSmallestNumber = numbers => Math.min(...numbers);
true - orange
const capitalizeFirstLetter = str => str.charAt(0).toUpperCase() + str.slice(1);
grape + 30,60,31,41,15,98,25,7,25,73,39,15,38,42,0,8,53,35,67,34,74,53,66,22,79,5,96,61,69,63,42,71,56,6,25,83,46,14,75,63,46,17,49,36,32,24,44,91,99,63,26,68,50,64,42,47,72,98,64,46,18,0,40,12,24,35,94,78,74,63,5,2
const findSmallestNumber = numbers => Math.min(...numbers);

64 - banana

const calculateFactorial = n => n === 0 ? 1 : n * calculateFactorial(n - 1);
const generateUUID = () => `${Math.random().toString(36).substr(2, 9)}-${Math.random().toString(36).substr(2, 9)}-${Math.random().toString(36).substr(2, 9)}-${Math.random().toString(36).substr(2, 9)}`;
const randomNumber = getRandomNumber();
const findSmallestNumber = numbers => Math.min(...numbers);
const rotateArrayLeft = (array, k) => { const rotations = k % array.length; return [...array.slice(rotations), ...array.slice(0, rotations)]; };
grape

const capitalizeString = str => str.toUpperCase();
if (getRandomBoolean()) { console.log("True"); } else { console.log("False"); }
44 / apple
const findLargestNumber = numbers => Math.max(...numbers);

const binarySearch = (array, target) => { let start = 0, end = array.length - 1; while (start <= end) { const mid = Math.floor((start + end) / 2); if (array[mid] === target) return mid; else if (array[mid] < target) start = mid + 1; else end = mid - 1; } return -1; };
orange


// This is a comment
const memoize = fn => { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); return cache.has(key) ? cache.get(key) : (cache.set(key, fn(...args)), cache.get(key)); }; };
